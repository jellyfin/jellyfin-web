import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import {
    cleanupOutdatedCaches,
    createHandlerBoundToURL,
    precacheAndRoute
} from 'workbox-precaching';
import { NavigationRoute, registerRoute, setCatchHandler } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';

// Take control of the page immediately
clientsClaim();

// Clean up old caches that are no longer needed
cleanupOutdatedCaches();

// Precache all assets generated by webpack
// The __WB_MANIFEST variable will be replaced with the list of files to cache
precacheAndRoute(self.__WB_MANIFEST);

// ---------------------------------------------------------------------------
// API Caching (NetworkFirst)
// ---------------------------------------------------------------------------
// Match any request that includes specific API paths
const apiMatchCallback = ({ url }) => {
    return (
        url.pathname.includes('/emby/') ||
        url.pathname.includes('/jellyfin/') ||
        url.pathname.includes('/api/') ||
        url.pathname.includes('/Items/') ||
        url.pathname.includes('/Users/') ||
        url.pathname.includes('/System/')
    );
};

registerRoute(
    apiMatchCallback,
    new NetworkFirst({
        cacheName: 'jellyfin-api-v1',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200]
            }),
            new ExpirationPlugin({
                maxEntries: 100,
                maxAgeSeconds: 24 * 60 * 60 // 24 Hours
            })
        ]
    })
);

// ---------------------------------------------------------------------------
// Image Caching (CacheFirst)
// ---------------------------------------------------------------------------
const imageMatchCallback = ({ request, url }) => {
    return (
        request.destination === 'image' ||
        url.pathname.includes('/images/') ||
        url.pathname.includes('/thumbnails/') ||
        url.pathname.includes('/logos/') ||
        url.pathname.includes('/backdrop/')
    );
};

registerRoute(
    imageMatchCallback,
    new CacheFirst({
        cacheName: 'jellyfin-images-v1',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200]
            }),
            new ExpirationPlugin({
                maxEntries: 200,
                maxAgeSeconds: 30 * 24 * 60 * 60 // 30 Days
            })
        ]
    })
);

// ---------------------------------------------------------------------------
// Font Caching (CacheFirst)
// ---------------------------------------------------------------------------
registerRoute(
    ({ request }) => request.destination === 'font',
    new CacheFirst({
        cacheName: 'jellyfin-fonts-v1',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200]
            }),
            new ExpirationPlugin({
                maxEntries: 30,
                maxAgeSeconds: 365 * 24 * 60 * 60 // 1 Year
            })
        ]
    })
);

// ---------------------------------------------------------------------------
// Offline Fallback
// ---------------------------------------------------------------------------
// If a navigation request fails, serve index.html (SPA) or offline.html
// For the SPA, precacheAndRoute typically handles the app shell (index.html).
// However, if we are truly offline and the AppShell matches, it works.
// If it fails (e.g. API error or uncached page), we might want a specific offline page.

// Catch-all handler for offline
setCatchHandler(async ({ event }) => {
    if (event.request.destination === 'document') {
        // Return offline.html if available in precache, otherwise index.html
        return (await caches.match('/offline.html')) || caches.match('/index.html');
    }
    // Return nothing (or a placeholder image) for other requests
    return Response.error();
});

// ---------------------------------------------------------------------------
// Message Handling
// ---------------------------------------------------------------------------
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
});
